
-----------------------------------------------
■ドキュメント
https://sass-lang.com/documentation/syntax
https://github.com/sass/sass

■本体
https://github.com/sass/dart-sass

★コンパイルされるもの、されないもの
⇒明記はされていなかったけど、たぶんSCSSの
　・$var　⇒される
　・function()　⇒される(実行結果が出力)
　　⇒新しめのSASSからは
　・通常のCSSの関数的な書き方（rotate3d()とか。関数ではない？ちょっとわからん）はそのまま出力される。

★インストール時の注意
・Dart-sassはChocorateyを使ってインストールする。
　gemでインストールするとRuby sassが入ってた・・
　どのsassが入ってるかはバージョンの確認と、サポートされているものの有無で試しながら確認すればよい？

■Syntax
⇒構文解析とか（定義可能場所とか）
　⇒でもOverview的な感じ、そんなに見なくてもいいかも
■Style Rules
〇ネストのルール（https://sass-lang.com/documentation/style-rules#selector-lists）
　※※大事：ネストが深くなるとコンパイルされたCSSの一つのCSS定義内のセレクタ指定が多くなる。
　　　　　　ブラウザのレンダリングはセレクタ数が多いと極端に遅くなる（セレクタを右から解析するため）ので、ネストを深くしないようにする。
　　　　　　最大で3ネストまで位が良さげ。可読性の観点的にも。
　★ネストルール(SCSS ⇒ CSS)
  ■E {F {}} ⇒ E F{}　※通常のネスト：子孫セレクタになる
  ■.A, .B {.C, .D {}} ⇒ .A .C, .A .D, .B .C, .B .D {} ※セレクタリスト　⇒組み合わせのセレクタリストになる
  ■セレクタコンビネータ（どの書き方も出力は同じ）
  　E > { F {}}    ⇒ E > F {}
  　E { + F {}}    ⇒ E + F {}
  　E { ~ {F {}}}  ⇒ E ~ F {}

　・ショートハンド的なネスト
　　https://sass-lang.com/documentation/style-rules/declarations#nesting
　　margin {
      top: 10px;
      bottom: 10px
    }
    みたいな書き方

〇親セレクタ(&) &を使用して親セレクタ参照
　E {&:hover {}} ⇒ E:hover {}
　E {F & {}}    ⇒ F E {}  ※右側に親を持ってくるテクニック
　E {:not(&)}   ⇒ :not(E){}
　こんなテクニックもある クラス名の生成
  .class {&_test {}} ⇒ .class_test {}

〇プレースホルダーセレクタ(%と@extend)
  CSSには出力されない定義。@extendで継承させるためだけの定義的な。
  https://kaminarimagazine.com/web/2016/09/30/sass-%E3%83%97%E3%83%AC%E3%83%BC%E3%82%B9%E3%83%9B%E3%83%AB%E3%83%80%E3%83%BC%E3%82%92%E4%BD%BF%E3%81%8A%E3%81%86%EF%BC%81/
  
■Variables
・定義
$variable: 12px
※注意：ハイフンとアンダースコアを同等とみなす。つまり
定義　$val_a: #111;
呼び出し　$val_a ※#111
呼び出し　$val-a ※#111

・有効範囲
トップレベルで定義：グローバル
ブロック内で定義：そのブロック内でのみ有効

■Interpolation（補完：※変数埋め込み的な）　https://sass-lang.com/documentation/interpolation
　#{$var}

■@Rules（https://sass-lang.com/documentation/at-rules） TODO: 一通り見る
〇補足 - CSS自体の特定の@rulesを、SASSでは以下のようにコンパイルする（https://sass-lang.com/documentation/at-rules/css#media）
　・@media: CSSでは@ruleはトップレベルにしか書けない。SASSの@mediaのみ特殊で、ネストされたブロック内にも書ける
　　　　　　⇒コンパイル結果はリンク先参照（一言で言うと子セレクタで指定した@mediaは親セレクタを囲うようにしてコンパイルされる）
　・@supports: これもブロックレベル内に定義するとコンパイル結果がいろいろする
@use 変数,mixin,functionのロード

@forword
@import
@mixin and @inclued
@function
@extend
@error
　FW開発、チーム開発用。コンパイル時にエラーを出し、中断する。
@warn
　FW開発、チーム開発用。コンパイル時に警告を出す。
@debug
　デバッグログを出力
@at-root
　ルール内のすべてがルートに出力される。
---Flow Control----
@if and @else
@each
@for
@while

■Values
値は基本的に通常のCSSと同じ型を使用する。
SASS固有でよく使いそうなものはこんな感じ
・list: 以下の二つは同じ意味。実際に 使うときは@eachとかで使う。Immutable(定義後に変更不可)
  (val, val, val)、(val val val)
・map: Immutable(定義後に変更不可)　これ自体は有効なCSSではないので、ふつうは@forとかで展開して使う。
  ("regular": 400, "medium": 500, "bold": 700);
  ※キーはダブルクォーテーションで囲うことを推奨。
・true false ※@ifとかif()で使う
・null ※主に関数の戻り値で使う。nullの場合はCSSは未定義となる。

※SASS固有の値は、CSSの有効な値ではない。関数等の処理用に使う目的。

■Operators
これ見るのがいい、結構簡潔にまとまってる
結構複雑だからそもそも計算処理とかはあんまりやらない方がいいのではという所感
★上手く使えばもっと柔軟なレスポンシブができる？
　⇒できなさそう？演算子自体がCSSのプロパティではないため、CSSには計算後の値が出力される。
割り算は / ではなく math.div()を使う。※Gridの / とステートメントがバッティングするため。
https://sass-lang.com/documentation/operators

■Built-in Modules
@use "sass:map"とかでインポートして使う
ざっと見て使いそうなのは
list.slash($elements...)　※grid-template定義するときに。。
map.get($map, $key, $keys...)
★math系は上手く使えば画面サイズによっていろいろ切り替えとかできるかも？わかんないけど
selector系もうまく使えれば結構いろいろできそう
selector.append($selectors...)
selector.nest($selectors...)



■Braeking Change
・演算子
　例えば「$size: 10px; margin: 15px -$size;」
　⇒margin: 15px -10pxなのかmargin 5pxなのかどっち？問題
　　⇒演算子として有効：15px - $size
　　⇒演算子として有効：15px-$size
　　⇒演算子として無効：15px -$size
・Gridで使用するスラッシュと、SASSの除算が同じスラッシュを使っている問題
 https://sass-lang.com/documentation/breaking-changes/slash-div
 ⇒SASSはCSSのスーパーセットなので、Gridではスラッシュを使う
 　※代わりにlist.slash()を使うこともできる
 ⇒除算はmath.div()を使う。
■Command Line
https://sass-lang.com/documentation/cli/dart-sass
ひとまず使いそうなのは
-w --watch　※ファイルの変更の監視
--poll　　　※ポーリング（ループ？）で監視　ファイル保存アクションがSASSに通知されない（=--watchが使えない）みたいなときはこっち使う。
くらい
–stop-on-error
--trace
■Javascript API
　⇒ライブラリ作成者向けっぽい

